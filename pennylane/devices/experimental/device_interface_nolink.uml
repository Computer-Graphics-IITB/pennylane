@startuml

package QML <<PennyLane catch all>> {
    class QuantumScript {
        +circuit: List[Operations, Observables]
        +observables: List[Observables]
        +operations: List[Operations]
        +trainable_params: List[int]
        +get_parameters(): Result
    }

    package Results <<execution result types>>{

        interface Result

        class NumericResult{
            Catch-all for interface\nagnostic numeric data
            --
            +data(): List[Union[int, float]]
        }

        class RemoteRef{
            Remote data reference using
            futures, Actor, etc.
            --
            +data(): NumericResult
        }

    }


    class QNode {
        +device: Device
        '+runtime_manager: RTManager
        +qscript: QuantumScript
        +QNode(dev: str, dev_config: DeviceConfig)(qscript: QuantumScript) 
    }

    package DeviceInterface <<Folder>> {
        class DeviceType <<Enum>>{
            VIRTUAL
            PHYSICAL
            UNKNOWN
        }
        class DeviceConfig <<dataclass>>{
            +device_type: DeviceType
            +misc_options
        }
        abstract class AbstractDeviceDriver{
            Low-level platform interface.
            --
            -device_config: DeviceConfig
            -device_reference: AbstractDeviceHandle
        }

        interface Device{
            {abstract} execute(qscript: Union[QuantumScript, List[QuantumScript]]): Result
            {abstract} gradient(qscript: QuantumScript, order: int): Result
            {abstract} vjp(qscript: QuantumScript): Result
            {abstract} pre(qscript: QuantumScript): Tuple(Union[QuantumScript, List[QuantumScript]], Union[Callable, None])
            {abstract} post(result: Union[Result, List[Result]], proc_fn: Union[Callable, None]): Result
        }

        abstract class AbstractDevice{
            -q_resource: DeviceDriver
            '-runtime_mgr: RTManager <<optionally here or QNode>>
            +register_execute(fn: Callable)
            +register_grad(fn: Callable, grad_order: int)
            +register_vjp(fn: Callable)
            +register_pre(fn: Callable)
            +register_post(fn: Callable)
            +get_capabilities(): DeviceConfig
        }
    }

    package CustomDevice <<Folder>> {
        class CustomDeviceDriver {
        }
        class CustomDevice {
        }
    }

    'QNode ..> Device
    'QNode ..> RTManager
    'QNode ..> QuantumScript

    RemoteRef -l- NumericResult

    Result <|-- NumericResult
    Result <|-- RemoteRef

    'QuantumScript .l.> Result

    CustomDeviceDriver --|> AbstractDeviceDriver
    CustomDevice --|> AbstractDevice
    CustomDevice -r- CustomDeviceDriver

    'RuntimeExecutionConfig .r.> FnType
    'RTManager -- RuntimeExecutionConfig
    'Manager ..> DeviceFactory
    'Manager ..> AbstractDevice
    'Manager ..> Result
    'Manager ..> QuantumScript

    AbstractDevice --|> Device

    AbstractDevice .r. AbstractDeviceDriver


    DeviceConfig *-- DeviceType

    'AbstractDevice ..> Result
    'AbstractDevice *-- DeviceDriver : optional
    'DeviceDriver o-- DeviceConfig

    class DeviceFactory{
        +create(device_name: string): AbstractDevice
        +create(device_name: string, device_config: DeviceConfig): AbstractDevice
    }
    DeviceFactory .u.> Device

    Result -u[hidden]- QNode

}

@enduml
